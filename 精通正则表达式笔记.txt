正则表达式：强大，便捷，高效的文本处理工具，能添加，删除，分离，叠加，插入和修整各种类型的文本和数据
  完整的正则表达式由两种字符构成：特殊字符和普通文本字符
  元字符^代表开始 $代表结束，匹配的是一个位置，而不是具体的文本（例：^cat匹配的是以c作为第一行的第一个字符，紧接着一个a，紧接着一个t的文本，cat$只寻找位于行末的cat）
  字符组：例gr[ea]y：先找到g，跟着是一个r，然后是一个a或者e，最后是一个y
  元字符-表示一个范围例如[1-6]可以匹配1至6的数字中的任意一个（只有在字符组内部才是元字符，否则只是普通的连字符号）
  
  [^cat$]文字意义：匹配的条件是，行开头，然后是字母c a t，然后是行末尾
         应用意义：只包含cat的行--没有多余的单词，空白字符 只有‘cat’
  [^$]文字意义：匹配的条件是，行开头，然后就是行末尾
      应用意义：空行（没有任何字符，包括空白字符）
  [^]文字意义：匹配条件是行的开头
     应用意义：无意义！因为每一行都有开头，所以每一行都能匹配--空行也不例外

  [^]:排除，是不希望匹配的字符（排除型字符组表示“匹配一个未列出的字符”）
       例如：q[^u]不会匹配到Iraq或者Qantas之类的
  [.]:用来配任意字符的字符组的简便写法(空格符也是普通字符之一)
    
  [|]: 意思是或（or），多选结构可以包括很多字符，但不能超越括号的界限
       [^from|subject|date: ]与[^(from|subject|date): ]不同
  量词：（）限定所所用元素的匹配次数
  [?]:代表可选项，处于字符后面，表示此处容许出现一次这个字符，不出现也没事
      例如：[4th|4]简化为[4(th)?]
  [+]:表示之前紧邻的元素出现一次或多次
  [*]:表示之前紧邻的元素出现任意多次，或者不出现。  
  
  [\]:转义符，使元字符失去特殊含义

  
编写正则表达式的时候，按照预期获得成功的匹配要花去一般的功夫，另一半用来考虑如何忽略不符合要求的文本

如果打算对许多字符串应用同一条正则表达式，最好通过re.complie创建regex对象，这样可以节省大量CPU时间
findall返回的时字符串中所有的匹配项，serach则返回第一个匹配项,match更严格，只匹配字符串的首部
sub()方法会将匹配到的模式替换为指定字符串，并返回所得到的新字符串
